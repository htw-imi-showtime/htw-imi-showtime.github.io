<!doctype html><html lang=en dir=ltr><link rel=stylesheet href=https://htw-imi-showtime.github.io/style.css><script src=/js/title-animate.js></script><script src=/js/semester-select.js></script><body><nav class="background master"><a href=https://htw-imi-showtime.github.io/ class=animate-trigger><strong>IMI<span class=light>×</span><span class=animate>ST</span></strong> <span class=light>21/22</span></a>
<input type=checkbox id=menu-btn>
<label for=menu-btn><span></span></label><ul><li><a href=/projects>Projects</a></li><li><a href=/schedule>Schedule</a></li><li><a href=/dates>Dates</a></li><li><a href=/ss21>Archive</a></li><li><a href=/contact>Contact</a></li></ul></nav><div class="background master"><header class=project-header><h1><span class=type>M3 Master</span>
Intelligentes Bilanzkreismanagement
<span class=underscore-spacer> </span></h1><section style=text-align:right><div class=spacer></div><h4>Team</h4><ul><li>Katharina Blass</li><li>Robin Decker</li><li>Mischa Koischwitz</li><li>Alain Ngoufack Nguefack</li><li>Nguyen Do</li><li>The-Anh Nguyen</li><li>Nhu Mong Tran</li></ul><h4>Supervision</h4>Dr. Ludwig Rauch</section></header></div><div class="project-menu desktop-menu background master"><ul><li><a href=/ws21/master/m4-intelligentes-bilanzkreismanagement/>Overview</a></li><li><a href=/ws21/master/m4-intelligentes-bilanzkreismanagement/features/>Features</a></li><li class=active><a href=/ws21/master/m4-intelligentes-bilanzkreismanagement/process/>Process</a></li><li><a href=/ws21/master/m4-intelligentes-bilanzkreismanagement/tech-stack/>Tech Stack</a></li><li><a href=/ws21/master/m4-intelligentes-bilanzkreismanagement/future/>Future</a></li></ul></div><div class="project-menu mobile-menu background master"><ul><li><a href=/ws21/master/m4-intelligentes-bilanzkreismanagement/>Overview</a></li><li><a href=/ws21/master/m4-intelligentes-bilanzkreismanagement/features/>Features</a></li></ul><input type=checkbox id=project-menu-button>
<label for=project-menu-button><span></span></label><div class=dropdown-menu><ul><li class=active><a href=/ws21/master/m4-intelligentes-bilanzkreismanagement/process/>Process</a></li><li><a href=/ws21/master/m4-intelligentes-bilanzkreismanagement/tech-stack/>Tech Stack</a></li><li><a href=/ws21/master/m4-intelligentes-bilanzkreismanagement/future/>Future</a></li></ul></div></div><main class=project><section><h3>General</h3><div class=spacer></div><div class=content><h4 id=scrum>Scrum</h4><p>Our entire project management was based on the Scrum framework. In order to be as flexible and organized as possible we structured the project into bi-weekly sprints.
Before each sprint we did an extensive sprint planning, guessing story points which reflect the complexity of each user story and defining what we want to get done within the sprint.
If needed we ended the sprint with a retrospective. Our process also included technical and functional reviews.</div></section><section><h3>Design</h3><div class=spacer></div><div class=content><h4 id=research-user-interviews--user-testing>Research, User Interviews & User Testing</h4><p>Since none of our team members initially knew what balancing group management is, we invested a small amount of time in researching the topic, understanding what the regular tasks of a balancing group manager is.</p><p>Our first goal was to keep the project as close to the user&rsquo;s needs as possible. Therefore and in order to get a better understanding of what the user actually needs we prepared a user interview.
Through Exxeta we were able to do the user interview with a balancing group manager. This helped us to understand the daily tasks of the user and what features would be important to have in a minimum viable product.</p><p>During the evaluation of the user interview we clustered the results and extracted different features out of the information we gathered.
These were then encapsulated into user stories which were the foundation of our sprints.</p><figure><img src=/ws21/master/m4-intelligentes-bilanzkreismanagement/InterviewNotes.jpg alt="Interview Notes"><figcaption>Screenshot of our Miro Board - Clustered Interview Notes and Result</figcaption></figure><p>For our final user test we prepared a complete user flow through the application. The interviewee then was prompted small tasks that would require her/him to go through that user flow.
During the execution of those tasks we took notes on what went well and what problems the interviewee had to face when using the application.
We also payed close attention for feature and improvement suggestions that the interviewee would make.
As well as for the first interview, we again clustered all the notes and extracted future user stories for our application.</p><figure><img src=/ws21/master/m4-intelligentes-bilanzkreismanagement/UserTestNotes.jpg alt="Interview Notes"><figcaption>Screenshot of our Miro Board - Guideline, Clustered User Test Notes and Result</figcaption></figure><h4 id=our-design-process>Our Design Process</h4><p>The design process was straight forward as Katharina and Nhu already have had experience. With the help of <strong>Figma</strong>, the collaboration went smooth. In general, each one fiddled for herself at the beginning of each step. Afterwards, they came together and discussed their ideas, the advantages and disadvantages of the designs. After each bi-weekly sprint, the design decisions were presented to the whole team. We&rsquo;ve had the opportunity to work with Daniel Heusohn, a UX-Designer from Exxeta, from whom we received valueable feedback.</p><p>The design process was as follows:</p><ol><li><strong>Collect best practises and inspiration based on the user testing findings</strong></li><li><strong>Create a low-fidility prototype</strong></li><li><strong>Define the color scheme and typography</strong></li><li><strong>Create a high-fidility prototype</strong></li><li><strong>Create developer handoff page</strong></li></ol><p>Starting with <strong>collecting design inspiration and best practices</strong> and utilizing the well prepared user stories as guideline, Katharina and Nhu then jumped into creating a <strong>low-fidility protoype</strong>. A simple hand drawn wireframe UI kit has been used, which consists of a minimum of needed elements to create anything one could have had imagen. They played with different variations of screen designs to weigh up which compositions might be the best fit, resulting in ten promising screens, which made it to the final cut.</p><p>Following the wireframes, they created a <strong>high-fidility protoype</strong>. Parts of the Pegasus Design System and Material Icons have been used, because of its clean and fresh design. Something worth emphasizing are the various form elements and buttons, which were designed from scratch to fit our color scheme and look.</p><figure><img src=/ws21/master/m4-intelligentes-bilanzkreismanagement/FormElementsButtons.png alt="Interview Notes"><figcaption>Snippet of our Figma Project - Components (Form Elements and Buttons)</figcaption></figure><p>In the following are a few <strong>impressions</strong>:</p><figure><img src=/ws21/master/m4-intelligentes-bilanzkreismanagement/InitDashboard.png alt="Initial dashboard"><figcaption>Initial Dashboard</figcaption></figure><figure><img src=/ws21/master/m4-intelligentes-bilanzkreismanagement/Dashboard.png alt=Dashboard><figcaption>Dashboard</figcaption></figure><figure><img src=/ws21/master/m4-intelligentes-bilanzkreismanagement/Modal.png alt="Selection of key data"><figcaption>Key data selection</figcaption></figure><figure><img src=/ws21/master/m4-intelligentes-bilanzkreismanagement/Dateien.png alt="File System"><figcaption>File System</figcaption></figure><p>Check out our <strong>Figma project</strong>:</p><iframe style="border:1px solid rgba(0,0,0,.1)" width=800 height=450 src="https://www.figma.com/embed?embed_host=share&url=https%3A%2F%2Fwww.figma.com%2Ffile%2FCXp4b3vkUo48gMpkguhuVJ%2FiBKM%3Fnode-id%3D197%253A78727" allowfullscreen></iframe></div></section><section><h3>Development</h3><div class=spacer></div><div class=content><h4 id=frontend>Frontend</h4><p>During the early stages of our project we decided to build our application on Reactjs using Typescript, since it helps to avoid unforeseeable bugs in our app that otherwise would have come up using Javascript.
We also wanted to have a <strong>great performance</strong>, <strong>easy scalability</strong> and all in all <strong>high quality</strong> for the frontend.
In order to reach that goal we decided to use Tailwind css and its utility first approach. While in traditional Css it is common to build classes in which different properties define how a certain element behaves and looks,
using the utility first approach flips this idea and instead provides classes that hold one specific property. The component then can be styled by combining these classes.</p><figure><img src=/ws21/master/m4-intelligentes-bilanzkreismanagement/UfBeforeAfter.png alt="Example before/after utility first apporach"><figcaption>Markup example before and after Utility First</figcaption></figure><p>Through the Utility First approach we were able to focus on building our components without having to take care of scaling our Css or use specific methodologies like BEM.
When building the app the final Css file only contains the classes that we actually used in our code which helps to avoid loading a complete and huge Css library and therefore <strong>guarantees fast rendering time</strong> in the browser.</p><p>Since we were already using Tailwind Css we decided to use Headless Ui for our UI components like dropdown menus, transitions, tabs, etc. The reason for this decision was to keep the frontend as independent and lightweight as possible.</p><p>During the entire development process we made sure that everything we develop during a sprint would get a full technical/code and functional review to ensure that we only deliver quality, readable code that is easy to maintain and extended in the future.
We also implemented basic unit tests for our frontend using Cypress</p><h4 id=backend>Backend</h4><p>The backend was built using the Expressjs framework running on a Nodejs Server on AWS Lambda. The main task of the backend is to process and transform CSV files with raw forecast data which were generated by the KI-Model and stored on another S3 bucket. After processing our backend provides the data in JSON format to our frontend using a http endpoint.
In order to minimize resources and setup, as well as server costs, we built the project based on a serverless architecture using AWS Lambda functions. These only run when their http endpoint gets called and only require a minimum of computing power. One Lambda Function on AWS usually only has one task, so whenever our application has to be extended in the future it is very easy to implement more functionality by adding more Lambda Functions.
Building the app this way, we avoid all fix costs for the project because there is no need for renting servers. The only (variable) cost centers are:</p><ul><li>The storage that the prediction data and our React app requires.</li><li>The Computing Power (RAM) that our Lambda functions require when they run.</li></ul><p>Since machine learning predictions are usually difficult to understand, we used explainable AI in our project context to make the prediction plausible. The balancing group manager should be able to justify his decision-making to his superiors at any time by basing his purchase decision on the various influencing factors presented in the UI. This way, the user is able to check experiences and intuitions against the influencing factors and add more weight to the validity of his purchase decision. To enable explainable AI, it was necessary to analyze the existing machine learning model responsible for prediction using a framework. For this purpose we used the Python framework LIME. This allowed us to describe which input features of a model had contributed to the prediction and to what extent. We then had to standardize the explanations of the input features to the scale from 0 to 1. Furthermore, it was necessary to logically cluster the input features for our use case and to sum up the contributions of the individual features to the clusters.</p></div></section><section><h3>Challenges</h3><div class=spacer></div><div class=content><p>Starting the project were brimming with finite ideas, but due to time constraints we had to reduce ourselves to the most important features. With the help of the initially conducted user interview, we were able to map a complete working user flow within our MVP. Eventually, we were able to validate these ideas in a user test.</p><p>When building our frontend using Tailwind css we wanted to stick to the Utility First approach as close to it as possible. Unfortunately we encountered some edge cases that required us to write classic Css for example when animating our basic components like our input text field or when implementing focus, active and hover states for our elements.</p><p>Furthermore the entire concept of serverless software architecture was new to us, so we had to invest a good amount of time in research before we were able to start developing. Creating an AWS account to test the technology was a challenge, as this had to be done in several steps with verification directly through Amazon. In the end, we have the following new technologies in hand: AWS services including Lambda function, s3 bucket, serverless framework to deploy the function.</p></div></section></main><footer><section><a href=https://htw-imi-showtime.github.io/ class=animate-trigger><strong>IMI<span class=light>⨯</span><span class=animate>ST</span></strong>
21/22</a><ul><li><a href=/contact>Contact</a></li><li><a href=/privacy-policy>Privacy Policy</a></li><li><a href=/imprint>Imprint</a></li></ul></section><img src=/img/htw-logo.png alt="HTW Logo"></footer></body></html>